4.Factor2 Securing Images

Secure container images, part 1

- So by now, you should be able to recognize the importance of secure design and code in setting a solid foundation for a secure container ecosystem. But at some point in the software development lifecycle, you or the developers in your organization are going to build a container image. And a container image comes with its own set of security issues related to its integrity and configuration. Such security issues must be addressed independently. Moreover, a container image is not just built, it is also are stored, transported, and then retrieved by many players of this ecosystem. So we need to make sure that both the image and the image registry are protected at every stage. And second, no defects should be introduced in the image that will later appear as vulnerabilities while running the containers. So let's take a look at the security controls you should implement to protect these images while in rest or in motion. We will start with the security controls required at the time of image creation. A container image is a collection of multiple layers built using the Union File System, where each change to the file system is stored as a separate layer. Each incremental layer represents the delta of changes from the previous layer. The layer also contains the metadata including a layer or a commit ID. Although you can create a container image in many ways, the most common and practical way is to use a Dockerfile. A Dockerfile is a plain text file with step by step instructions on how to build an image. Not only a Dockerfile makes it easy to see how an image was built, but it also allows you to check in the file in the source code repository and track it just like the rest of your source code. Note that the Dockerfile defines not only the code that goes into your image, but also the configuration and the environment under which the image will run. And that puts an enormous amount of power in the hands of the author, or anyone who can get their hands onto the file. So let's dissect a Dockerfile and look at the security best practices you can put in place. The FROM directive in a Dockerfile tells the container platform such as Docker, which base image to use. This base image will be the bottom most layer of your final container image. Start with an image whose content and the source is known. Your organization might already maintain a set of golden base images that are trusted and made available via an enterprise image repository. These golden images are safe to use because they have been scanned for security vulnerabilities, vetted and meet the organization's security policies. The attack surface of your container is directly proportional to the number of software components present in its image. Larger the number of components, the greater the probability that one of them has a security flaw that is exploitable by an attacker. There are a few ways you can reduce the attack surface. You already know that you should start from a trusted base image. But you should also start with a minimal base image in the FROM directive. There is no need to begin with say a traditional Ubuntu Linux image with all kinds of utilities and modules still in it. Instead, use a minimal image such as Alpine, BusyBox, or something similar. Or if you prefer, you can create your own base image by literally starting from scratch. Even if you start with a minimal base image, you still have the option to add additional software components. For example, add and copy commands in Dockerfile allows you to add additional content into the image file system. You should ask, do you really need to add that extra component just because you can? For example, do you need to add SSH web server or even the Bash shell? Look, if you keep your image bloated with unnecessary components, you will have few consequences. If the extra component you added happens to be vulnerable, your entire image is at risk which can lead to the breach of the container. When a container is breached, these components can make attackers' job easier, helping them move around and even escalate privileges. For example, if an attacker gets access to your container, the attacker will need utilities such as a shell, cat, ls command, etc. If your container does not have these tools to begin with, you're making it harder for the attackers to carry out their job. Keep in mind though, this approach is a dual-edged sword. By stripping your image off these basic utilities, you're also making it difficult for yourself to debug any bugs.

Secure container images, part 2

-  The principle of least privilege implies that a subject which can be either a person or a service account should be granted only as much as access privileges as are needed to perform their job. Under no circumstances should they be given a blanket privilege beyond their role. The user instruction in Dockerfile specifies, the user, the container will be running as. If you don't specify a user in the Dockerfile, the container runs as a root by default. And for most containers, which are running business applications that is beyond the level of privileges they actually need. Keep in mind that unless you are building a system container that really needs to interact with the OS Kernel, no container needs route access. Setting a setuid bit on a file in a Unix-like operating system has some interesting consequences. Typically, when a Linux process is started from a file, the process runs with the permissions of the executer. But when the process is started from a file with the setuid bit on, the process runs with the permissions of the owner of the file. This behavior has some repercussions for security and can lead to privilege escalation. Let's say you were careful enough to specify a username the image should run as, but you happen to include a binary with setuid bit in your image. When someone runs that binary, the process starts with a different set of privileges. For example, if the owner of the binary happened to be root, the process will be running with the root privileges. And this is a form of privilege escalation, you didn't want that process to run as root. Therefore, don't include binaries with setuid bit bit turned on. Now, even if you intentionally minimize the attack surface, chances are that unsolicited objects will creep into your image. These unwanted objects can take many forms, but all of them make your containers vulnerable. For example, a malware that is a malicious executable that gets added into your image intentionally or accidentally. Malware can create a backdoor to your container and make it accessible to attackers. Ironically, you can accidentally introduce malware by getting a malicious image from a public repository. Another kind of object that you don't want in your image is a Secret. A Secret is anything that is confidential and can unlock access to private data. For example, passwords, private keys or connection strings and so on. We only know about the problem of Secrets in source-code repositories. If you have not solved that problem, chances are that the same habits and practice will manifest in the image file system as well. So how do you take care of these unwanted issues with the images and what security controls should you put in place? Scan your images, identify the security issues, whether these are embedded malware, embedded secrets or security vulnerabilities and address them before your image is run as a container. Ideally, if you follow the secure design, code and scanning practices, we discussed in prior chapters, there should be minimal vulnerabilities in your image. But things change, new vulnerabilities are discovered. Let's say you didn't find any security bugs in the code and the image was clean when the developers built it. That may not be true today or in the future when you're about to run your containers. So when and how often should you scan your container images? First, scan an image in your Continuous Integration or CI pipeline immediately after building the image. Second, integrate scanning directly with the image registry, so that the images are being scanned continuously in the background and are flagged based on their vulnerability status. This will prevent vulnerable images from being downloaded in the first place. There are several open source and commercial tools available in the market. For example, Claire, Kube-bench, aquasec, and Twistlock. These tools will help you scan for security vulnerabilities, configuration defects, policy violations, and even compliance with security Benchmarks from CIS.

Image registries

Let's switch focus from images to image registries and building trust in them. You know, that you should only use a trusted base image to create your container images. But how do you know if the image you just acquired has not been tampered with, and is from a source you know and trust? Risks associated with using images built by someone else are similar to risks with using third party software components. But the problem is a bit more nuanced for container images. Since the final image is actually a collection of multiple layers, each layer may be created by a separate user. So we need a mechanism to establish trust in the complete chain of custody. This trust in the image is established through a process known as image signing. Image signing enables its author to add its identity to the image. This identity is in the form of a digital signature. The user of the image then verifies the integrity of the image before starting to use it. Now, of course, for your organization, you can implement an image signing framework from the scratch. But many commercial container image registries, you already use, include some implementation of an image signing framework. Few open source projects provide frameworks for image signing. The update framework or in short TUF started in 2019, is a general framework for software updates. This framework includes a set of libraries and utilities that can be used to secure the software upgrade process. Keep in mind that this framework is not specific to container images only. Another CNCF open source project called notary, is an implementation of the update framework that is suitable for distributing container images. With notary, the creator of the image, signs the image, using a secure private key. The creator pushes the content to the notary server. Users of the images, verify the image using the public key that they received from the creator via an out-of-band channel. Now granted the current implementation of notary has few challenges. And we will continue to see the enhancements in the next version of notary. Your container images include your businesses intellectual property. If you transport these images to or from an image registry over an insecure network, you run the risk of a variety of security attacks. An attacker could intercept the clear text connection and sniff the confidential data. There is also a risk of a man in the middle attack whereby an attacker can intercept and serve malicious images to the requester. So what should you do? Always encrypt the connection to the registry, use the latest version of the TLS protocol, but will that be enough.