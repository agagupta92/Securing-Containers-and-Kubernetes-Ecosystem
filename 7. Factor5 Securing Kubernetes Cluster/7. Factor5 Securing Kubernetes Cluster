7. Factor5 Securing Kubernetes Cluster


Cluster security goals

-  We now know the security features and capabilities offered by Kubernetes. These feature allow developers and admins to establish security controls that protect your running pods. These features also play a significant role in protecting the rest of the Kubernetes infrastructure. These core components are not typically accessed by your application. They work behind the scenes to keep the cluster running. But how do you protect them? We have identified a few key goals, protect the API server traffic and the Kubernetes cluster components, prevent resource overuse, secure the Kubernetes network, and finally, the secrets. We will look at each one of them.

Securing API server traffic

- Authentication and role-based access control enable users and service accounts to communicate with the API Server. But remember, Kubernetes native components also frequently communicate with the API Server. Kubelets, kube-scheduler, kube-proxy, and kube-controller-manager must connect to API Server via a secure port. These clients must also authenticate themselves. Make sure that in the API Server specification file, the insecure-port parameter is set to zero. If you set up an API Server on the default insecure-port 8080, you are allowing attackers unencrypted access to the API Server. The secure-port parameter is used to serve HTTPS traffic. Ensure that its value, if defined, is between one and 65535. In addition, ensure that the insecure-bind-address doesn't exist. API Server should be configured to serve and accept only HTTPS traffic. That will require you to set up TLS, so check out the Kubernetes documentation on how to do that. Also, make sure in the API Server specification file, the client-ca-file parameter exists, and it points to the correct path of the file containing certificate authorities. Similarly, ensure that the parameters related to TLS certificate file and private keys are set appropriately.

Securing cluster components

- You need to protect at etcd store. Limit access to it, of course, with the exception of the API server, and only serve clients over TLS. Secrets are stored in the etcd store, so you must ensure that the secret data at rest is encrypted. Starting with Kubernetes version 1.13 and etcd version 3.0 onwards, Kubernetes supports encryption of secrets. By default, Kubelet allows anonymous requests. Ensure that you only allow authenticated and authorized requests. And again, only serve over a secure connection. Kubernetes offers various mechanisms to manage the users of resources at the cluster and namespace level. You want to put these restrictions in place to protect from a noisy neighbor that wants to hog all compute and memory resources. This can help you protect from a denial of service attack due to malicious containers. Similar to pod security policy admission controller, which we saw earlier, you can use ResourceQuota to prevent pods from running that don't meet the pre-specified CPU and memory limits. Likewise, setting up limit range allows you to prevent users from requesting high values of your resources. To protect your network, implement namespaces in a large enterprise multi-application environment. We already saw how network policies can help control traffic in a cluster. Use a network plugin provider that supports network policies. Utilize quota and limit ranges to control access to your load balancers. Load balancers expose your application to the outside world, and you want to carefully control users who can have access. Encrypt secrets at rest and in transit. Use the latest version of Kubernetes supporting encryption of secrets in etcd. Use TLS to ensure that the confidential data in transit is not accessible to others. Rotate your secrets frequently. Remove the service account token after it is no longer needed. And finally, reduce the lifespan of a secret. The shorter the lifespan, the less likely it is going to be usable by an attacker.