3.Factor1 Securing Containerized Application Code

Secure design before code

-  Every enterprise goal is that its containers in production are not only free today, but remain free of security vulnerabilities. It is also expected that these containers remain compliant with the organization's security policies at all times. So it is natural to believe that scanning and monitoring your containers and kubernetes environment for security and policy violations is going to be imperative. But is that enough? Don't get me wrong. Such security controls are extremely important and necessary as you will see in the later chapters, but they are not sufficient. Why? Because by the time you end up scanning thousands of running containers, not only you have missed an opportunity to catch a security bug early on, but you're also being inefficient as well. If these containers are instantiated from the same image, you could have found many configuration defects and vulnerabilities from that one single image. You could have also blocked it from running as a container in the first place. By the same argument, if you have multiple container images being generated out of the same codebase, it is more effective to secure that source code itself. In other words, there is a case for finding security vulnerabilities as early as possible in the software development life cycle. We saw in the previous chapters that developers build images from homegrown code, third party components, libraries, and OS components. The security of such images and containers is only as good as the security of the objects being placed inside them. So why not shift security all the way to the left? A Secure Development Lifecycle or SDL, emphasizes embedding security into all stages of a software development lifecycle. We will go to some of the key security controls you should put in place. But for a comprehensive treatment of the subject, I encourage you to review the publications by SAFECode organization, National Institute of Standards and Technology or NIS, and other courses on LinkedIn. Start with security requirements. Place the security of your application at par with features and functional requirements. Work with the product managers and owners to ensure that the user stories related to security are prioritized and not pushed to the backlog to be handled later as mere checkboxes. A secure application is contingent upon having a secure architecture. Understand and apply the foundational principles of secure design. To secure an application from the ground up, an application architect or developer should be comfortable applying the following design principles at minimum, the principle of least privilege, defense in depth, separation of duties, and minimizing the attack surface. In fact, in the next chapters, you will watch the very same principles I'm advocating applied to secure containers, hosts, and the kubernetes clusters. Threat modeling typically done at the design stage, enables your engineering team to look at your architecture from an adversary's point of view. The goal of threat modeling is to enumerate external threats and discover weaknesses in your design. You should apply threat modeling techniques to find and then mitigate such weaknesses so that you can prevent a poor design from being implemented in the first place.

Secure code

-  Secure architecture and threat modeling will get your engineering team to a solid foundation. But there is no guarantee that the code developers will write will be free of bugs. More specifically, the security bugs. Securing code requires a multi-pronged approach. The approach includes peer code reviews, automated scanning of the code and the software components at various stages in your software development life cycle. Poor and unsafe programming habits leads to security bugs in the code. These innocent-looking security bugs, if not fixed early, will morph into security vulnerabilities in your containers running in the production. This process of identifying security issues in the source code by scanning and analyzing is popularly known as static analysis security testing, or SAST in short. Educate your developers to write secure code in the first place. Train them on how to use the output of these scanning tools to locate unsafe core blocks. And finally, complete the feedback loop by ensuring that the security bugs are addressed before the code is promoted or merged into the next level branch. You'll have multiple opportunities to run a static analysis of your code, first in the integrated development environment or the IDE of the developer. This allows the developers to get immediate feedback on the security issues in their code. Next, you can run a static analysis directly on the source code repository and integrate it with the developer's workflow. This will give you the option to scan the code with every pull or merge request. If you're running a continuous integration pipeline, there is another opportunity to run the scan in the pipeline immediately after the code commit. Brand new code written by developers can be analyzed by SAST tools. But what about the code that has been acquired from third parties? You want to identify all components that may contain security vulnerabilities. Perform software composition analysis of your code so you know the true bill of material of your code. Many open source and commercial tools can assist you with this type of analysis. So when should you run these tools? Just as in the case of SAST, you have multiple opportunities. Integrate component scan in your enterprise artifact repository so anytime a developer pulls or pushes a software component, it is scanned at the artifact repository level. Many commercial tools integrate directly with the repositories. These tools continuously apply your security policy to block vulnerable components from being used. You can and should run a component scan in your CI/CD pipeline where possible in your workflow. Static code and software composition analysis can give you the confidence that the code is secure, but you still want to be sure that when the code turns into running application, it can withstand the attacks of an adversary. Before you deploy your application into your production environment, utilize specialized tools that test the application for commonly found security weaknesses. This type of application testing is known as dynamic application security testing, or DAST in short.